Sensitivity Study readme
========================

Cheryl Patrick (UCL)
May 17, 2017

========================

The Sensitivity Study contains several utilities of varying degrees of reusability (for example, they include some hardcoded paths to files on my own disk). If people want to use any of this, I can tidy it up and make it accessible to other users.

Included in this study, I have:

- SensitivityModule (Falaise pipeline module to process selected data from the SD, CD, TCD, TTD and PTD banks and output a ROOT file. Has significant overlap with the ParticleID module, but is not the same).

- AnalyseSensitivity (Runs a 0nubb half-life sensitivity study, sequentially applying basic cuts to tuples generated by the SensitivityModule. Takes samples from 0nubb, 2nubb, and various backgrounds, and calculates a sensitivity using TLimit. Background rates may be incorrect; use with caution).

feedthroughEfficiency (plots efficiencies of various cuts for gammas of different energies and origins that might result from alpha-n interactions in the CuBe feedthroughs)

energyResolution (just a quick and dirty script to figure out how the calorimeter energy and time resolution in simulation relate to the energy/time. Might be of use to someone sometime?)

- backgroundStudy (Uses things2root tuples looking at the SD bank to plot various truth quantities for background samples)

More detail below
—————————————————

=================
SensitivityModule
=================
Files:
SensitivityModule.cpp
SensitivityModule.conf
SensitivityModule.h
CMakeLists.txt

Add to an flreconstruct pipeline to generate a ROOT ntuple file with some pertinent branches. SensitivityModule.conf gives an example of how I run it; in this case my input file would be something that had already been through the standard flreconstruct pipeline, and that includes SD, CD, TCD, TTD, PTD banks. The output file will always be called sensitivity.root so don’t run it multiple times concurrently in the same directory!
CMakeLists.txt will build it on my Mac; I don’t guarantee (or even expect) it will work everywhere. In fact I know it doesn’t, but you can use it as a starting point.

This is the structure of the tuple that it makes:


sensitivity.passes_two_calorimeters : True if there are exactly 2 reconstructed calorimeter hits over 50 keV, of which at least 1 is over 150keV (CD bank)

sensitivity.passes_two_clusters : True if there are exactly two reconstructed clusters with 3 or more hits (TCD bank)

sensitivity.passes_two_tracks : True if there are exactly two reconstructed tracks (TTD bank)

sensitivity.passes_associated_calorimeters : True if passes_two_calorimeters and passes_two_calorimeters  AND each of those two hits is associated to a separate track. In future I plan to remove the restriction of the 2 calorimeters and 2 tracks, but it is currently in place. (PTD bank)

sensitivity.number_of_electrons : Number of tracks with a negative charge. Only set when we have two tracks and two calorimeter hits (that does not need to be the case, we could move it). (PTD bank)

sensitivity.total_calorimeter_energy : Summed energy of all reconstructed calorimeter hits (CD bank)

sensitivity.higher_electron_energy :  Highest reconstructed calorimeter energy - not necessarily actually from an electron (CD bank)

sensitivity.lower_electron_energy : Second-highest reconstructed calorimeter energy - not necessarily actually from an electron (CD bank)
                               
sensitivity.true_higher_electron_energy :  Same as true_highest_primary_energy
                        
sensitivity.true_lower_electron_energy : Same as  sensitivity.true_second_primary_energy

sensitivity.true_highest_primary_energy : The energy of the highest-energy primary particle in the interaction (from SD bank)

sensitivity.true_second_primary_energy : The energy of the second-highest-energy primary particle in the interaction (from SD bank)
   
sensitivity.true_total_energy : Summed energy of every primary particle in the interaction (from SD bank)

sensitivity.first_vertex_x : If there are two tracks, vertex x position of an arbitrary “first” track. Foil is at x ~ 0, main calo walls are at +/- 434.994 mm according to flvisualize. Unit is mm.

sensitivity.first_vertex_y : If there are two tracks, vertex y position of an arbitrary “first” track. The y direction is horizontal, parallel to the foil, you can see it in top view. Unit is mm.

sensitivity.first_vertex_z : If there are two tracks, vertex z position of an arbitrary “first” track. The z direction is vertical, parallel to the wires, you can see it in side view. Unit is mm.

sensitivity.second_vertex_x : If there are two tracks, vertex x position of an arbitrary “2nd” track. Foil is at x ~ 0, main calo walls are at +/- 434.994 mm according to flvisualize. Unit is mm.

sensitivity.second_vertex_y :  If there are two tracks, vertex y position of an arbitrary “2nd” track. The y direction is horizontal, parallel to the foil, you can see it in top view. Unit is mm.

sensitivity.second_vertex_z : If there are two tracks, vertex z position of an arbitrary “2nd” track. The z direction is vertical, parallel to the wires, you can see it in side view. Unit is mm.

sensitivity.vertex_separation : Distance between the inner-most (nearest to the foil) vertices of the two tracks (only if there are 2 tracks).  Unit is mm.

sensitivity.first_projected_vertex_y
sensitivity.first_projected_vertex_z
sensitivity.second_projected_vertex_y
sensitivity.second_projected_vertex_z: Only if there are 2 tracks. If both tracks were linearly projected back to the foil (x=0), these would be their y and z coordinates.  Unit is mm.

sensitivity.foil_projection_separation : Only if there are 2 tracks. If both tracks were linearly projected back to the foil, this is the distance between where the tracks intersect the foil.  Unit is mm.

sensitivity.vertices_on_foil : If 2 tracks: number of tracks with a vertex on the foil.

sensitivity.first_vertices_on_foil : Obsolete

sensitivity.angle_between_tracks : If 2 tracks: Angle between the initial momentum vectors of the two tracks. Does not require them to share a vertex (maybe it should)

sensitivity.same_side_of_foil : If 2 tracks: True if both tracks are on the same side of the foil, false if not

sensitivity.first_track_momentum_x :                               sensitivity.first_track_momentum_y :                               sensitivity.first_track_momentum_z :                               sensitivity.second_track_momentum_x :                              sensitivity.second_track_momentum_y :                              sensitivity.second_track_momentum_z :  Initial momentum vectors for the two tracks (Only if two tracks, arbitrary which is which)

sensitivity.time_delay : If 2 calorimeter hits (both associated with tracks) - time delay in nanoseconds between the tracks. Used in the past as a crude proxy for internal/external probability.

sensitivity.internal_probability :  If 2 associated tracks, this calculates the probability that it is an internal event (both tracks are initiated in the foil). If internal, this should be equally distributed from 0 to 1. If external (particle leaves one calorimeter, travels to foil, then to another calorimeter) this will be very close to 0. Calculated from energy and time of calorimeter hits vs length or tracks.

sensitivity.internal_chi_squared :  Intermediate step to calculating internal_probability

sensitivity.external_probability : If 2 associated tracks, this calculates the probability that it is an external event (particle leaves one calorimeter, travels to foil, then to another calorimeter).  If external, this should be equally distributed from 0 to 1. If internal  (both tracks are initiated in the foil) this will be very close to 0. Calculated from energy and time of calorimeter hits vs length or tracks.

sensitivity.external_chi_squared :  Intermediate step to calculating external_probability
                               
sensitivity.foil_projected_internal_chi_squared
sensitivity.foil_projected_external_chi_squared: As internal and external chi squared, if each track’s length were extended to project the track linearly back to the foil

sensitivity.calorimeter_hit_count: Number of calorimeter hits

sensitivity.small_cluster_count: Number of clusters with 2 hits

sensitivity.cluster_count: Number of clusters with 3 or more hits

sensitivity.third_calo_energy: Third-highest calorimeter energy

sensitivity.edgemost_vertex: Absolute y position (in mm) of the vertex that is nearest to the edge of the detector in the y dimension. This could possibly be used with small cluster identification to find events near the edge of the detector who have two tracks, each associated with a calorimeter and with close vertices on the foil, but for one of which there are only 2 hits (because it is too near the edge to pass through 3 cells).

====================
AnalyseSensitivity
====================

Requires the Sensitivity ntuple format of SensitivityModule. Is set up to run on selenium samples (which are hardcoded in there right now) but adding Nd150 and Ca48 would be straightforward (just uncomment a couple of lines of code in main()) if you had the simulation to look at. This code requires input tuple files for samples of:
0nubb
2nubb (I generated this only for events over 2MeV total energy, if you do that you will need to work out the fraction of total 2nubb events that actually got simulated)

It makes efficiency plots for a variety of cut combinations, at the moment I am trying with and without a charge requirement and with and without internal/external probablity, on top of the standard cut set (2 calorimeter hits, 2 associated tracks). Probably some of these combinations are not needed (why would we not use the int/ext probability? Just there to compare with old studies) and it would be easy to add new ones (e.g. vertex distance requirement) in MakePlotsForIsotope.

Output plots are:
- energy distribution for 0nubb and 2nubb (Area normalised)
- efficiency for 0nubb and 2nubb if a lower minimum cut were made
- efficiencies with background isotopes
	- Tl208 in foil
	- Bi214 in foil
	- Bi214 on foil surface (mylar)
	- Tl208 on foil surface (mylar)
	- Bi214 on wires (from radon in tracker)
   I am not confident of the activities for these.

We then use this to calculate sensitivity
	- vs minimum energy cut, but ignoring backgrounds, using window method
	- overall using TLimit, ignoring backgrounds
	- overall using TLimit, including backgrounds
Method is taken from James Mott’s thesis


=====================
feedthroughEfficiency
=====================
A somewhat rough program to plot the efficiency of reconstructing gammas that might come from (alpha, n) reactions in the feedthroughs. I use ntuples produced from Falaise simulation/standard reconstructed pipeline and the SensitivityModule.

Includes hard-coded regions of interest for the two isotopes (Se82:2.8-3.2 MeV, Nd150:3.2-3.6 MeV) which might not be what we use in the end. Selection of gamma energies and source positions in the detector (need to be matched to corresponding simulation, which is currently hardcoded to simulation I’ve generated). Assuming you provide the files, it will do Nd150 or Se82 (remember to use variant service to change the foil to Nd150 when simulating).

Three command line options:
isotope:	“nd”, “Nd”, “nd150” or “Nd150” give Nd-150, else Se-82
location:	ft (=feedthrough)
		cw (=calorimeter wrapper)
		sh (=shielding)
		all (loops through all location/energy combos)
energy:		if “4” then 4 MeV gammas, else 7-8 (again this is just matching to simulation files I have made)

Files are saved to subdirectory feedthroughplots.